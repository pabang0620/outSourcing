"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts_transformer_1 = require("@formatjs/ts-transformer");
const util_1 = require("../util");
function checkNode(context, node, { idInterpolationPattern, idWhitelistRegexps }) {
    const msgs = (0, util_1.extractMessages)(node, (0, util_1.getSettings)(context));
    for (const [{ message: { defaultMessage, description, id }, idPropNode, descriptionNode, messagePropNode, },] of msgs) {
        if (!idInterpolationPattern && !idPropNode) {
            context.report({
                node: node,
                message: `id must be specified`,
            });
        }
        else if (idInterpolationPattern) {
            if (!defaultMessage) {
                context.report({
                    node: node,
                    message: `defaultMessage must be a string literal to calculate generated IDs`,
                });
            }
            else if (!description && descriptionNode) {
                context.report({
                    node: node,
                    message: `description must be a string literal to calculate generated IDs`,
                });
            }
            else {
                if (idWhitelistRegexps &&
                    id &&
                    idWhitelistRegexps.some((r) => r.test(id))) {
                    // messageId is allowlisted so skip interpolation id check
                    return;
                }
                const correctId = (0, ts_transformer_1.interpolateName)({
                    resourcePath: context.getFilename(),
                }, idInterpolationPattern, {
                    content: description
                        ? `${defaultMessage}#${description}`
                        : defaultMessage,
                });
                if (id !== correctId) {
                    let message = `"id" does not match with hash pattern ${idInterpolationPattern}`;
                    if (idWhitelistRegexps) {
                        message += ` or allowlisted patterns ["${idWhitelistRegexps
                            .map(r => r.toString())
                            .join('", "')}"]`;
                    }
                    context.report({
                        node: node,
                        message: `${message}.
Expected: ${correctId}
Actual: ${id}`,
                        fix(fixer) {
                            if (idPropNode) {
                                if (idPropNode.type === 'JSXAttribute') {
                                    return fixer.replaceText(idPropNode, `id="${correctId}"`);
                                }
                                return fixer.replaceText(idPropNode, `id: '${correctId}'`);
                            }
                            // Insert after default message node
                            if (messagePropNode.type === 'JSXAttribute') {
                                return fixer.insertTextAfter(messagePropNode, ` id="${correctId}"`);
                            }
                            return fixer.insertTextAfter(messagePropNode, `, id: '${correctId}'`);
                        },
                    });
                }
            }
        }
    }
}
exports.default = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce (generated) ID in message descriptor',
            category: 'Errors',
            recommended: false,
            url: 'https://formatjs.io/docs/tooling/linter#enforce-id',
        },
        fixable: 'code',
        schema: [
            {
                type: 'object',
                properties: {
                    idInterpolationPattern: {
                        type: 'string',
                        description: 'Pattern to verify ID against. Recommended value: [sha512:contenthash:base64:6]',
                    },
                    idWhitelist: {
                        type: 'array',
                        description: "An array of strings with regular expressions. This array allows allowlist custom ids for messages. For example '`\\\\.`' allows any id which has dot; `'^payment_.*'` - allows any custom id which has prefix `payment_`. Be aware that any backslash \\ provided via string must be escaped with an additional backslash.",
                        items: {
                            type: 'string',
                        },
                    },
                },
                required: ['idInterpolationPattern'],
                additionalProperties: false,
            },
        ],
    },
    create(context) {
        const tmp = context?.options?.[0];
        const opts = {
            idInterpolationPattern: tmp?.idInterpolationPattern,
        };
        if (Array.isArray(tmp?.idWhitelist)) {
            const { idWhitelist } = tmp;
            opts.idWhitelistRegexps = idWhitelist.map((str) => new RegExp(str, 'i'));
        }
        const callExpressionVisitor = (node) => checkNode(context, node, opts);
        if (context.parserServices.defineTemplateBodyVisitor) {
            return context.parserServices.defineTemplateBodyVisitor({
                CallExpression: callExpressionVisitor,
            }, {
                CallExpression: callExpressionVisitor,
            });
        }
        return {
            JSXOpeningElement: (node) => checkNode(context, node, opts),
            CallExpression: callExpressionVisitor,
        };
    },
};
