'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var SentryCli = require('@sentry/cli');
var fs = require('fs');
var path = require('path');
var MagicString = require('magic-string');
var unplugin = require('unplugin');
var findUp = require('find-up');
var os = require('os');
var crypto = require('crypto');
var childProcess = require('child_process');
var glob = require('glob');
var util = require('util');
var utils = require('@sentry/utils');
var node = require('@sentry/node');
var dotenv = require('dotenv');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var SentryCli__default = /*#__PURE__*/_interopDefaultLegacy(SentryCli);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);
var findUp__default = /*#__PURE__*/_interopDefaultLegacy(findUp);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var childProcess__default = /*#__PURE__*/_interopDefaultLegacy(childProcess);
var util__namespace = /*#__PURE__*/_interopNamespace(util);
var dotenv__namespace = /*#__PURE__*/_interopNamespace(dotenv);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

/**
 * Checks whether the given input is already an array, and if it isn't, wraps it in one.
 *
 * @param maybeArray Input to turn into an array, if necessary
 * @returns The input, if already an array, or an array with the input as the only element, if not
 */
function arrayify(maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
}
/**
 * Get the closes package.json from a given starting point upwards.
 * This handles a few edge cases:
 * * Check if a given file package.json appears to be an actual NPM package.json file
 * * Stop at the home dir, to avoid looking too deeply
 */
function getPackageJson() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    cwd = _ref.cwd,
    stopAt = _ref.stopAt;
  return lookupPackageJson(cwd !== null && cwd !== void 0 ? cwd : process.cwd(), path__default["default"].normalize(stopAt !== null && stopAt !== void 0 ? stopAt : os__default["default"].homedir()));
}
function parseMajorVersion(version) {
  // if it has a `v` prefix, remove it
  if (version.startsWith("v")) {
    version = version.slice(1);
  }

  // First, try simple lookup of exact, ~ and ^ versions
  var regex = /^[\^~]?(\d+)(\.\d+)?(\.\d+)?(-.+)?/;
  var match = version.match(regex);
  if (match) {
    return parseInt(match[1], 10);
  }

  // Try to parse e.g. 1.x
  var coerced = parseInt(version, 10);
  if (!Number.isNaN(coerced)) {
    return coerced;
  }

  // Match <= and >= ranges.
  var gteLteRegex = /^[<>]=\s*(\d+)(\.\d+)?(\.\d+)?(-.+)?/;
  var gteLteMatch = version.match(gteLteRegex);
  if (gteLteMatch) {
    return parseInt(gteLteMatch[1], 10);
  }

  // match < ranges
  var ltRegex = /^<\s*(\d+)(\.\d+)?(\.\d+)?(-.+)?/;
  var ltMatch = version.match(ltRegex);
  if (ltMatch) {
    // Two scenarios:
    // a) < 2.0.0 --> return 1
    // b) < 2.1.0 --> return 2

    var major = parseInt(ltMatch[1], 10);
    if (
    // minor version > 0
    typeof ltMatch[2] === "string" && parseInt(ltMatch[2].slice(1), 10) > 0 ||
    // patch version > 0
    typeof ltMatch[3] === "string" && parseInt(ltMatch[3].slice(1), 10) > 0) {
      return major;
    }
    return major - 1;
  }

  // match > ranges
  var gtRegex = /^>\s*(\d+)(\.\d+)?(\.\d+)?(-.+)?/;
  var gtMatch = version.match(gtRegex);
  if (gtMatch) {
    // We always return the version here, even though it _may_ be incorrect
    // E.g. if given > 2.0.0, it should be 2 if there exists any 2.x.x version, else 3
    // Since there is no way for us to know this, we're going to assume any kind of patch/feature release probably exists
    return parseInt(gtMatch[1], 10);
  }
  return undefined;
}

// This is an explicit list of packages where we want to include the (major) version number.
var PACKAGES_TO_INCLUDE_VERSION = ["react", "@angular/core", "vue", "ember-source", "svelte", "@sveltejs/kit", "webpack", "vite", "gatsby", "next", "remix", "rollup", "esbuild"];
function getDependencies(packageJson) {
  var _packageJson$devDepen, _packageJson$dependen;
  var dependencies = Object.assign({}, (_packageJson$devDepen = packageJson["devDependencies"]) !== null && _packageJson$devDepen !== void 0 ? _packageJson$devDepen : {}, (_packageJson$dependen = packageJson["dependencies"]) !== null && _packageJson$dependen !== void 0 ? _packageJson$dependen : {});
  var deps = Object.keys(dependencies).sort();
  var depsVersions = deps.reduce(function (depsVersions, depName) {
    if (PACKAGES_TO_INCLUDE_VERSION.includes(depName)) {
      var version = dependencies[depName];
      var majorVersion = parseMajorVersion(version);
      if (majorVersion) {
        depsVersions[depName] = majorVersion;
      }
    }
    return depsVersions;
  }, {});
  return {
    deps: deps,
    depsVersions: depsVersions
  };
}
function lookupPackageJson(cwd, stopAt) {
  var jsonPath = findUp__default["default"].sync(function (dirName) {
    // Stop if we reach this dir
    if (path__default["default"].normalize(dirName) === stopAt) {
      return findUp__default["default"].stop;
    }
    return findUp__default["default"].sync.exists(dirName + "/package.json") ? "package.json" : undefined;
  }, {
    cwd: cwd
  });
  if (!jsonPath) {
    return undefined;
  }
  try {
    var jsonStr = fs__default["default"].readFileSync(jsonPath, "utf8");
    var json = JSON.parse(jsonStr);

    // Ensure it is an actual package.json
    // This is very much not bulletproof, but should be good enough
    if ("name" in json || "private" in json) {
      return json;
    }
  } catch (error) {
    // Ignore and walk up
  }

  // Continue up the tree, if we find a fitting package.json
  var newCwd = path__default["default"].dirname(path__default["default"].resolve(jsonPath + "/.."));
  return lookupPackageJson(newCwd, stopAt);
}

/**
 * Deterministically hashes a string and turns the hash into a uuid.
 */
function stringToUUID(str) {
  var md5sum = crypto__default["default"].createHash("md5");
  md5sum.update(str);
  var md5Hash = md5sum.digest("hex");

  // Position 16 is fixed to either 8, 9, a, or b in the uuid v4 spec (10xx in binary)
  // RFC 4122 section 4.4
  var v4variant = ["8", "9", "a", "b"][md5Hash.substring(16, 17).charCodeAt(0) % 4];
  return (md5Hash.substring(0, 8) + "-" + md5Hash.substring(8, 12) + "-4" + md5Hash.substring(13, 16) + "-" + v4variant + md5Hash.substring(17, 20) + "-" + md5Hash.substring(20)).toLowerCase();
}
function gitRevision() {
  var gitRevision;
  try {
    gitRevision = childProcess__default["default"].execSync("git rev-parse HEAD").toString().trim();
  } catch (e) {
    // noop
  }
  return gitRevision;
}

/**
 * Tries to guess a release name based on environmental data.
 */
function determineReleaseName() {
  return (
    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
    process.env["GITHUB_SHA"] ||
    // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
    process.env["COMMIT_REF"] ||
    // Cloudflare Pages - https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables
    process.env["CF_PAGES_COMMIT_SHA"] ||
    // AWS CodeBuild - https://docs.aws.amazon.com/codebuild/latest/userguide/build-env-ref-env-vars.html
    process.env["CODEBUILD_RESOLVED_SOURCE_VERSION"] ||
    // Bitbucket - https://support.atlassian.com/bitbucket-cloud/docs/variables-and-secrets/
    process.env["BITBUCKET_COMMIT"] ||
    // CircleCI - https://circleci.com/docs/2.0/env-vars/
    process.env["CIRCLE_SHA1"] ||
    // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
    process.env["VERCEL_GIT_COMMIT_SHA"] || process.env["VERCEL_GITHUB_COMMIT_SHA"] || process.env["VERCEL_GITLAB_COMMIT_SHA"] || process.env["VERCEL_BITBUCKET_COMMIT_SHA"] ||
    // Zeit (now known as Vercel)
    process.env["ZEIT_GITHUB_COMMIT_SHA"] || process.env["ZEIT_GITLAB_COMMIT_SHA"] || process.env["ZEIT_BITBUCKET_COMMIT_SHA"] ||
    // Flightcontrol - https://www.flightcontrol.dev/docs/guides/flightcontrol/environment-variables#built-in-environment-variables
    process.env["FC_GIT_COMMIT_SHA"] || gitRevision()
  );
}

/**
 * Generates code for the global injector which is responsible for setting the global
 * `SENTRY_RELEASE` & `SENTRY_BUILD_INFO` variables.
 */
function generateGlobalInjectorCode(_ref2) {
  var release = _ref2.release,
    injectBuildInformation = _ref2.injectBuildInformation;
  // The code below is mostly ternary operators because it saves bundle size.
  // The checks are to support as many environments as possible. (Node.js, Browser, webworkers, etc.)
  var code = "\n    var _global =\n      typeof window !== 'undefined' ?\n        window :\n        typeof global !== 'undefined' ?\n          global :\n          typeof self !== 'undefined' ?\n            self :\n            {};\n\n    _global.SENTRY_RELEASE={id:\"".concat(release, "\"};");
  if (injectBuildInformation) {
    var buildInfo = getBuildInformation$1();
    code += "\n      _global.SENTRY_BUILD_INFO=".concat(JSON.stringify(buildInfo), ";");
  }
  return code;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function generateModuleMetadataInjectorCode(metadata) {
  // The code below is mostly ternary operators because it saves bundle size.
  // The checks are to support as many environments as possible. (Node.js, Browser, webworkers, etc.)
  return "\n    var _global2 =\n      typeof window !== 'undefined' ?\n        window :\n        typeof global !== 'undefined' ?\n          global :\n          typeof self !== 'undefined' ?\n            self :\n            {};\n\n    _global2._sentryModuleMetadata = _global2._sentryModuleMetadata || {};\n    _global2._sentryModuleMetadata[new Error().stack] = ".concat(JSON.stringify(metadata), ";");
}
function getBuildInformation$1() {
  var packageJson = getPackageJson();
  var _ref3 = packageJson ? getDependencies(packageJson) : {
      deps: [],
      depsVersions: {}
    },
    deps = _ref3.deps,
    depsVersions = _ref3.depsVersions;
  return {
    deps: deps,
    depsVersions: depsVersions,
    nodeVersion: parseMajorVersion(process.version)
  };
}
function stripQueryAndHashFromPath(path) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return path.split("?")[0].split("#")[0];
}
function replaceBooleanFlagsInCode(code, replacementValues) {
  var ms = new MagicString__default["default"](code);
  Object.keys(replacementValues).forEach(function (key) {
    var value = replacementValues[key];
    if (typeof value === "boolean") {
      ms.replaceAll(key, JSON.stringify(value));
    }
  });
  if (ms.hasChanged()) {
    return {
      code: ms.toString(),
      map: ms.generateMap({
        hires: true
      })
    };
  }
  return null;
}

var SENTRY_SAAS_URL = "https://sentry.io";
function normalizeUserOptions(userOptions) {
  var _userOptions$org, _userOptions$project, _userOptions$authToke, _ref, _userOptions$url, _userOptions$debug, _userOptions$silent, _userOptions$telemetr, _userOptions$disable, _ref2, _userOptions$release$, _userOptions$release, _userOptions$release$2, _userOptions$release2, _userOptions$release$3, _userOptions$release3, _userOptions$release$4, _userOptions$release4, _ref3, _userOptions$release$5, _userOptions$release5, _userOptions$release$6, _userOptions$release6, _userOptions$_experim;
  var options = {
    org: (_userOptions$org = userOptions.org) !== null && _userOptions$org !== void 0 ? _userOptions$org : process.env["SENTRY_ORG"],
    project: (_userOptions$project = userOptions.project) !== null && _userOptions$project !== void 0 ? _userOptions$project : process.env["SENTRY_PROJECT"],
    authToken: (_userOptions$authToke = userOptions.authToken) !== null && _userOptions$authToke !== void 0 ? _userOptions$authToke : process.env["SENTRY_AUTH_TOKEN"],
    url: (_ref = (_userOptions$url = userOptions.url) !== null && _userOptions$url !== void 0 ? _userOptions$url : process.env["SENTRY_URL"]) !== null && _ref !== void 0 ? _ref : SENTRY_SAAS_URL,
    headers: userOptions.headers,
    debug: (_userOptions$debug = userOptions.debug) !== null && _userOptions$debug !== void 0 ? _userOptions$debug : false,
    silent: (_userOptions$silent = userOptions.silent) !== null && _userOptions$silent !== void 0 ? _userOptions$silent : false,
    errorHandler: userOptions.errorHandler,
    telemetry: (_userOptions$telemetr = userOptions.telemetry) !== null && _userOptions$telemetr !== void 0 ? _userOptions$telemetr : true,
    disable: (_userOptions$disable = userOptions.disable) !== null && _userOptions$disable !== void 0 ? _userOptions$disable : false,
    sourcemaps: userOptions.sourcemaps,
    release: _objectSpread2(_objectSpread2({}, userOptions.release), {}, {
      name: (_ref2 = (_userOptions$release$ = (_userOptions$release = userOptions.release) === null || _userOptions$release === void 0 ? void 0 : _userOptions$release.name) !== null && _userOptions$release$ !== void 0 ? _userOptions$release$ : process.env["SENTRY_RELEASE"]) !== null && _ref2 !== void 0 ? _ref2 : determineReleaseName(),
      inject: (_userOptions$release$2 = (_userOptions$release2 = userOptions.release) === null || _userOptions$release2 === void 0 ? void 0 : _userOptions$release2.inject) !== null && _userOptions$release$2 !== void 0 ? _userOptions$release$2 : true,
      create: (_userOptions$release$3 = (_userOptions$release3 = userOptions.release) === null || _userOptions$release3 === void 0 ? void 0 : _userOptions$release3.create) !== null && _userOptions$release$3 !== void 0 ? _userOptions$release$3 : true,
      finalize: (_userOptions$release$4 = (_userOptions$release4 = userOptions.release) === null || _userOptions$release4 === void 0 ? void 0 : _userOptions$release4.finalize) !== null && _userOptions$release$4 !== void 0 ? _userOptions$release$4 : true,
      vcsRemote: (_ref3 = (_userOptions$release$5 = (_userOptions$release5 = userOptions.release) === null || _userOptions$release5 === void 0 ? void 0 : _userOptions$release5.vcsRemote) !== null && _userOptions$release$5 !== void 0 ? _userOptions$release$5 : process.env["SENTRY_VSC_REMOTE"]) !== null && _ref3 !== void 0 ? _ref3 : "origin",
      cleanArtifacts: (_userOptions$release$6 = (_userOptions$release6 = userOptions.release) === null || _userOptions$release6 === void 0 ? void 0 : _userOptions$release6.cleanArtifacts) !== null && _userOptions$release$6 !== void 0 ? _userOptions$release$6 : false
    }),
    bundleSizeOptimizations: userOptions.bundleSizeOptimizations,
    _experiments: (_userOptions$_experim = userOptions._experiments) !== null && _userOptions$_experim !== void 0 ? _userOptions$_experim : {}
  };
  return options;
}

/**
 * Validates a few combinations of options that are not checked by Sentry CLI.
 *
 * For all other options, we can rely on Sentry CLI to validate them. In fact,
 * we can't validate them in the plugin because Sentry CLI might pick up options from
 * its config file.
 *
 * @param options the internal options
 * @param logger the logger
 *
 * @returns `true` if the options are valid, `false` otherwise
 */
function validateOptions(options, logger) {
  var _options$release, _options$release2, _options$release3;
  var setCommits = (_options$release = options.release) === null || _options$release === void 0 ? void 0 : _options$release.setCommits;
  if (setCommits) {
    if (!setCommits.auto && !(setCommits.repo && setCommits.commit)) {
      logger.error("The `setCommits` option was specified but is missing required properties.", "Please set either `auto` or both, `repo` and `commit`.");
      return false;
    }
    if (setCommits.auto && setCommits.repo && setCommits) {
      logger.warn("The `setCommits` options includes `auto` but also `repo` and `commit`.", "Ignoring `repo` and `commit`.", "Please only set either `auto` or both, `repo` and `commit`.");
    }
  }
  if ((_options$release2 = options.release) !== null && _options$release2 !== void 0 && _options$release2.deploy && !((_options$release3 = options.release) !== null && _options$release3 !== void 0 && _options$release3.deploy.env)) {
    logger.error("The `deploy` option was specified but is missing the required `env` property.", "Please set the `env` property.");
    return false;
  }
  return true;
}

function createDebugIdUploadFunction(_ref) {
  var assets = _ref.assets,
    ignore = _ref.ignore,
    logger = _ref.logger,
    releaseName = _ref.releaseName,
    dist = _ref.dist,
    handleRecoverableError = _ref.handleRecoverableError,
    sentryHub = _ref.sentryHub,
    sentryClient = _ref.sentryClient,
    sentryCliOptions = _ref.sentryCliOptions,
    rewriteSourcesHook = _ref.rewriteSourcesHook,
    filesToDeleteAfterUpload = _ref.filesToDeleteAfterUpload;
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(buildArtifactPaths) {
      var artifactBundleUploadTransaction, folderToCleanUp, mkdtempSpan, tmpUploadFolder, globAssets, globSpan, globResult, debugIdChunkFilePaths, prepareSpan, preparationTasks, workers, worker, workerIndex, files, stats, uploadSize, uploadSpan, cliInstance, deleteGlobSpan, filePathsToDelete, deleteSpan, cleanupSpan;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            artifactBundleUploadTransaction = sentryHub.startTransaction({
              name: "debug-id-sourcemap-upload"
            });
            _context3.prev = 1;
            mkdtempSpan = artifactBundleUploadTransaction.startChild({
              description: "mkdtemp"
            });
            _context3.next = 5;
            return fs__default["default"].promises.mkdtemp(path__default["default"].join(os__default["default"].tmpdir(), "sentry-bundler-plugin-upload-"));
          case 5:
            tmpUploadFolder = _context3.sent;
            mkdtempSpan.finish();
            folderToCleanUp = tmpUploadFolder;
            if (assets) {
              globAssets = assets;
            } else {
              logger.debug("No `sourcemaps.assets` option provided, falling back to uploading detected build artifacts.");
              globAssets = buildArtifactPaths;
            }
            globSpan = artifactBundleUploadTransaction.startChild({
              description: "glob"
            });
            _context3.next = 12;
            return glob.glob(globAssets, {
              absolute: true,
              nodir: true,
              ignore: ignore
            });
          case 12:
            globResult = _context3.sent;
            globSpan.finish();
            debugIdChunkFilePaths = globResult.filter(function (debugIdChunkFilePath) {
              return debugIdChunkFilePath.endsWith(".js") || debugIdChunkFilePath.endsWith(".mjs") || debugIdChunkFilePath.endsWith(".cjs");
            }); // The order of the files output by glob() is not deterministic
            // Ensure order within the files so that {debug-id}-{chunkIndex} coupling is consistent
            debugIdChunkFilePaths.sort();
            if (!(Array.isArray(assets) && assets.length === 0)) {
              _context3.next = 20;
              break;
            }
            logger.debug("Empty `sourcemaps.assets` option provided. Will not upload sourcemaps with debug ID.");
            _context3.next = 47;
            break;
          case 20:
            if (!(debugIdChunkFilePaths.length === 0)) {
              _context3.next = 24;
              break;
            }
            logger.warn("Didn't find any matching sources for debug ID upload. Please check the `sourcemaps.assets` option.");
            _context3.next = 47;
            break;
          case 24:
            prepareSpan = artifactBundleUploadTransaction.startChild({
              description: "prepare-bundles"
            }); // Preparing the bundles can be a lot of work and doing it all at once has the potential of nuking the heap so
            // instead we do it with a maximum of 16 concurrent workers
            preparationTasks = debugIdChunkFilePaths.map(function (chunkFilePath, chunkIndex) {
              return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return prepareBundleForDebugIdUpload(chunkFilePath, tmpUploadFolder, chunkIndex, logger, rewriteSourcesHook !== null && rewriteSourcesHook !== void 0 ? rewriteSourcesHook : defaultRewriteSourcesHook);
                    case 2:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
            });
            workers = [];
            worker = /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                var task;
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      if (!(preparationTasks.length > 0)) {
                        _context2.next = 7;
                        break;
                      }
                      task = preparationTasks.shift();
                      if (!task) {
                        _context2.next = 5;
                        break;
                      }
                      _context2.next = 5;
                      return task();
                    case 5:
                      _context2.next = 0;
                      break;
                    case 7:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2);
              }));
              return function worker() {
                return _ref4.apply(this, arguments);
              };
            }();
            for (workerIndex = 0; workerIndex < 16; workerIndex++) {
              workers.push(worker());
            }
            _context3.next = 31;
            return Promise.all(workers);
          case 31:
            prepareSpan.finish();
            _context3.next = 34;
            return fs__default["default"].promises.readdir(tmpUploadFolder);
          case 34:
            files = _context3.sent;
            stats = files.map(function (file) {
              return fs__default["default"].promises.stat(path__default["default"].join(tmpUploadFolder, file));
            });
            _context3.next = 38;
            return Promise.all(stats);
          case 38:
            uploadSize = _context3.sent.reduce(function (accumulator, _ref5) {
              var size = _ref5.size;
              return accumulator + size;
            }, 0);
            artifactBundleUploadTransaction.setMeasurement("files", files.length, "none");
            artifactBundleUploadTransaction.setMeasurement("upload_size", uploadSize, "byte");
            uploadSpan = artifactBundleUploadTransaction.startChild({
              description: "upload"
            });
            cliInstance = new SentryCli__default["default"](null, _objectSpread2(_objectSpread2({}, sentryCliOptions), {}, {
              headers: _objectSpread2({
                "sentry-trace": uploadSpan.toTraceparent(),
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                baggage: utils.dynamicSamplingContextToSentryBaggageHeader(artifactBundleUploadTransaction.getDynamicSamplingContext())
              }, sentryCliOptions.headers)
            }));
            _context3.next = 45;
            return cliInstance.releases.uploadSourceMaps(releaseName !== null && releaseName !== void 0 ? releaseName : "undefined",
            // unfortunetly this needs a value for now but it will not matter since debug IDs overpower releases anyhow
            {
              include: [{
                paths: [tmpUploadFolder],
                rewrite: false,
                dist: dist
              }],
              useArtifactBundle: true
            });
          case 45:
            uploadSpan.finish();
            logger.info("Successfully uploaded source maps to Sentry");
          case 47:
            if (!filesToDeleteAfterUpload) {
              _context3.next = 58;
              break;
            }
            deleteGlobSpan = artifactBundleUploadTransaction.startChild({
              description: "delete-glob"
            });
            _context3.next = 51;
            return glob.glob(filesToDeleteAfterUpload, {
              absolute: true,
              nodir: true
            });
          case 51:
            filePathsToDelete = _context3.sent;
            deleteGlobSpan.finish();
            filePathsToDelete.forEach(function (filePathToDelete) {
              logger.debug("Deleting asset after upload: ".concat(filePathToDelete));
            });
            deleteSpan = artifactBundleUploadTransaction.startChild({
              description: "delete-files-after-upload"
            });
            _context3.next = 57;
            return Promise.all(filePathsToDelete.map(function (filePathToDelete) {
              return fs__default["default"].promises.rm(filePathToDelete, {
                force: true
              })["catch"](function (e) {
                // This is allowed to fail - we just don't do anything
                logger.debug("An error occured while attempting to delete asset: ".concat(filePathToDelete), e);
              });
            }));
          case 57:
            deleteSpan.finish();
          case 58:
            _context3.next = 64;
            break;
          case 60:
            _context3.prev = 60;
            _context3.t0 = _context3["catch"](1);
            sentryHub.withScope(function (scope) {
              scope.setSpan(artifactBundleUploadTransaction);
              sentryHub.captureException('Error in "debugIdUploadPlugin" writeBundle hook');
            });
            handleRecoverableError(_context3.t0);
          case 64:
            _context3.prev = 64;
            if (folderToCleanUp) {
              cleanupSpan = artifactBundleUploadTransaction.startChild({
                description: "cleanup"
              });
              void fs__default["default"].promises.rm(folderToCleanUp, {
                recursive: true,
                force: true
              });
              cleanupSpan.finish();
            }
            artifactBundleUploadTransaction.finish();
            _context3.next = 69;
            return sentryClient.flush();
          case 69:
            return _context3.finish(64);
          case 70:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[1, 60, 64, 70]]);
    }));
    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }();
}
function prepareBundleForDebugIdUpload(_x2, _x3, _x4, _x5, _x6) {
  return _prepareBundleForDebugIdUpload.apply(this, arguments);
}

/**
 * Looks for a particular string pattern (`sdbid-[debug ID]`) in the bundle
 * source and extracts the bundle's debug ID from it.
 *
 * The string pattern is injected via the debug ID injection snipped.
 */
function _prepareBundleForDebugIdUpload() {
  _prepareBundleForDebugIdUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(bundleFilePath, uploadFolder, chunkIndex, logger, rewriteSourcesHook) {
    var bundleContent, debugId, uniqueUploadName, writeSourceFilePromise, writeSourceMapFilePromise;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          _context5.next = 3;
          return util.promisify(fs__default["default"].readFile)(bundleFilePath, "utf8");
        case 3:
          bundleContent = _context5.sent;
          _context5.next = 10;
          break;
        case 6:
          _context5.prev = 6;
          _context5.t0 = _context5["catch"](0);
          logger.error("Could not read bundle to determine debug ID and source map: ".concat(bundleFilePath), _context5.t0);
          return _context5.abrupt("return");
        case 10:
          debugId = determineDebugIdFromBundleSource(bundleContent);
          if (!(debugId === undefined)) {
            _context5.next = 14;
            break;
          }
          logger.debug("Could not determine debug ID from bundle. This can happen if you did not clean your output folder before installing the Sentry plugin. File will not be source mapped: ".concat(bundleFilePath));
          return _context5.abrupt("return");
        case 14:
          uniqueUploadName = "".concat(debugId, "-").concat(chunkIndex);
          bundleContent += "\n//# debugId=".concat(debugId);
          writeSourceFilePromise = fs__default["default"].promises.writeFile(path__default["default"].join(uploadFolder, "".concat(uniqueUploadName, ".js")), bundleContent, "utf-8");
          writeSourceMapFilePromise = determineSourceMapPathFromBundle(bundleFilePath, bundleContent, logger).then( /*#__PURE__*/function () {
            var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(sourceMapPath) {
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!sourceMapPath) {
                      _context4.next = 3;
                      break;
                    }
                    _context4.next = 3;
                    return prepareSourceMapForDebugIdUpload(sourceMapPath, path__default["default"].join(uploadFolder, "".concat(uniqueUploadName, ".js.map")), debugId, rewriteSourcesHook, logger);
                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }));
            return function (_x15) {
              return _ref6.apply(this, arguments);
            };
          }());
          _context5.next = 20;
          return writeSourceFilePromise;
        case 20:
          _context5.next = 22;
          return writeSourceMapFilePromise;
        case 22:
        case "end":
          return _context5.stop();
      }
    }, _callee5, null, [[0, 6]]);
  }));
  return _prepareBundleForDebugIdUpload.apply(this, arguments);
}
function determineDebugIdFromBundleSource(code) {
  var match = code.match(/sentry-dbid-([0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12})/);
  if (match) {
    return match[1];
  } else {
    return undefined;
  }
}

/**
 * Applies a set of heuristics to find the source map for a particular bundle.
 *
 * @returns the path to the bundle's source map or `undefined` if none could be found.
 */
function determineSourceMapPathFromBundle(_x7, _x8, _x9) {
  return _determineSourceMapPathFromBundle.apply(this, arguments);
}
/**
 * Reads a source map, injects debug ID fields, and writes the source map to the target path.
 */
function _determineSourceMapPathFromBundle() {
  _determineSourceMapPathFromBundle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(bundlePath, bundleSource, logger) {
    var sourceMappingUrlMatch, sourceMappingUrl, isUrl, isSupportedUrl, url, absoluteSourceMapPath, adjacentSourceMapFilePath;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          // 1. try to find source map at `sourceMappingURL` location
          sourceMappingUrlMatch = bundleSource.match(/^\s*\/\/# sourceMappingURL=(.*)$/m);
          if (!sourceMappingUrlMatch) {
            _context6.next = 14;
            break;
          }
          sourceMappingUrl = path__default["default"].normalize(sourceMappingUrlMatch[1]);
          try {
            url = new URL(sourceMappingUrl);
            isUrl = true;
            isSupportedUrl = url.protocol === "file:";
          } catch (_unused) {
            isUrl = false;
            isSupportedUrl = false;
          }
          if (isSupportedUrl) {
            absoluteSourceMapPath = sourceMappingUrl;
          } else if (isUrl) ; else if (path__default["default"].isAbsolute(sourceMappingUrl)) {
            absoluteSourceMapPath = sourceMappingUrl;
          } else {
            absoluteSourceMapPath = path__default["default"].join(path__default["default"].dirname(bundlePath), sourceMappingUrl);
          }
          if (!absoluteSourceMapPath) {
            _context6.next = 14;
            break;
          }
          _context6.prev = 6;
          _context6.next = 9;
          return util__namespace.promisify(fs__default["default"].access)(absoluteSourceMapPath);
        case 9:
          return _context6.abrupt("return", absoluteSourceMapPath);
        case 12:
          _context6.prev = 12;
          _context6.t0 = _context6["catch"](6);
        case 14:
          _context6.prev = 14;
          adjacentSourceMapFilePath = bundlePath + ".map";
          _context6.next = 18;
          return util__namespace.promisify(fs__default["default"].access)(adjacentSourceMapFilePath);
        case 18:
          return _context6.abrupt("return", adjacentSourceMapFilePath);
        case 21:
          _context6.prev = 21;
          _context6.t1 = _context6["catch"](14);
        case 23:
          // This is just a debug message because it can be quite spammy for some frameworks
          logger.debug("Could not determine source map path for bundle: ".concat(bundlePath, " - Did you turn on source map generation in your bundler?"));
          return _context6.abrupt("return", undefined);
        case 25:
        case "end":
          return _context6.stop();
      }
    }, _callee6, null, [[6, 12], [14, 21]]);
  }));
  return _determineSourceMapPathFromBundle.apply(this, arguments);
}
function prepareSourceMapForDebugIdUpload(_x10, _x11, _x12, _x13, _x14) {
  return _prepareSourceMapForDebugIdUpload.apply(this, arguments);
}
function _prepareSourceMapForDebugIdUpload() {
  _prepareSourceMapForDebugIdUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(sourceMapPath, targetPath, debugId, rewriteSourcesHook, logger) {
    var sourceMapFileContent, map;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          _context7.prev = 0;
          _context7.next = 3;
          return util__namespace.promisify(fs__default["default"].readFile)(sourceMapPath, {
            encoding: "utf8"
          });
        case 3:
          sourceMapFileContent = _context7.sent;
          _context7.next = 10;
          break;
        case 6:
          _context7.prev = 6;
          _context7.t0 = _context7["catch"](0);
          logger.error("Failed to read source map for debug ID upload: ".concat(sourceMapPath), _context7.t0);
          return _context7.abrupt("return");
        case 10:
          _context7.prev = 10;
          map = JSON.parse(sourceMapFileContent);
          // For now we write both fields until we know what will become the standard - if ever.
          map["debug_id"] = debugId;
          map["debugId"] = debugId;
          _context7.next = 20;
          break;
        case 16:
          _context7.prev = 16;
          _context7.t1 = _context7["catch"](10);
          logger.error("Failed to parse source map for debug ID upload: ".concat(sourceMapPath));
          return _context7.abrupt("return");
        case 20:
          if (map["sources"] && Array.isArray(map["sources"])) {
            map["sources"] = map["sources"].map(function (source) {
              return rewriteSourcesHook(source, map);
            });
          }
          _context7.prev = 21;
          _context7.next = 24;
          return util__namespace.promisify(fs__default["default"].writeFile)(targetPath, JSON.stringify(map), {
            encoding: "utf8"
          });
        case 24:
          _context7.next = 30;
          break;
        case 26:
          _context7.prev = 26;
          _context7.t2 = _context7["catch"](21);
          logger.error("Failed to prepare source map for debug ID upload: ".concat(sourceMapPath), _context7.t2);
          return _context7.abrupt("return");
        case 30:
        case "end":
          return _context7.stop();
      }
    }, _callee7, null, [[0, 6], [10, 16], [21, 26]]);
  }));
  return _prepareSourceMapForDebugIdUpload.apply(this, arguments);
}
var PROTOCOL_REGEX = /^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//;
function defaultRewriteSourcesHook(source) {
  if (source.match(PROTOCOL_REGEX)) {
    return source.replace(PROTOCOL_REGEX, "");
  } else {
    return path__default["default"].relative(process.cwd(), path__default["default"].normalize(source));
  }
}

function releaseManagementPlugin(_ref) {
  var releaseName = _ref.releaseName,
    include = _ref.include,
    dist = _ref.dist,
    setCommitsOption = _ref.setCommitsOption,
    shouldCreateRelease = _ref.shouldCreateRelease,
    shouldCleanArtifacts = _ref.shouldCleanArtifacts,
    shouldFinalizeRelease = _ref.shouldFinalizeRelease,
    deployOptions = _ref.deployOptions,
    handleRecoverableError = _ref.handleRecoverableError,
    sentryHub = _ref.sentryHub,
    sentryClient = _ref.sentryClient,
    sentryCliOptions = _ref.sentryCliOptions;
  return {
    name: "sentry-debug-id-upload-plugin",
    writeBundle: function writeBundle() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var cliInstance, normalizedInclude;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              cliInstance = new SentryCli__default["default"](null, sentryCliOptions);
              if (!shouldCreateRelease) {
                _context.next = 5;
                break;
              }
              _context.next = 5;
              return cliInstance.releases["new"](releaseName);
            case 5:
              if (!shouldCleanArtifacts) {
                _context.next = 8;
                break;
              }
              _context.next = 8;
              return cliInstance.releases.execute(["releases", "files", releaseName, "delete", "--all"], true);
            case 8:
              if (!include) {
                _context.next = 12;
                break;
              }
              normalizedInclude = arrayify(include).map(function (includeItem) {
                return typeof includeItem === "string" ? {
                  paths: [includeItem]
                } : includeItem;
              }).map(function (includeEntry) {
                var _includeEntry$validat;
                return _objectSpread2(_objectSpread2({}, includeEntry), {}, {
                  validate: (_includeEntry$validat = includeEntry.validate) !== null && _includeEntry$validat !== void 0 ? _includeEntry$validat : false,
                  ext: includeEntry.ext ? includeEntry.ext.map(function (extension) {
                    return ".".concat(extension.replace(/^\./, ""));
                  }) : [".js", ".map", ".jsbundle", ".bundle"],
                  ignore: includeEntry.ignore ? arrayify(includeEntry.ignore) : undefined
                });
              });
              _context.next = 12;
              return cliInstance.releases.uploadSourceMaps(releaseName, {
                include: normalizedInclude,
                dist: dist
              });
            case 12:
              if (!setCommitsOption) {
                _context.next = 15;
                break;
              }
              _context.next = 15;
              return cliInstance.releases.setCommits(releaseName, setCommitsOption);
            case 15:
              if (!shouldFinalizeRelease) {
                _context.next = 18;
                break;
              }
              _context.next = 18;
              return cliInstance.releases.finalize(releaseName);
            case 18:
              if (!deployOptions) {
                _context.next = 21;
                break;
              }
              _context.next = 21;
              return cliInstance.releases.newDeploy(releaseName, deployOptions);
            case 21:
              _context.next = 29;
              break;
            case 23:
              _context.prev = 23;
              _context.t0 = _context["catch"](0);
              sentryHub.captureException('Error in "releaseManagementPlugin" writeBundle hook');
              _context.next = 28;
              return sentryClient.flush();
            case 28:
              handleRecoverableError(_context.t0);
            case 29:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[0, 23]]);
      }))();
    }
  };
}

function telemetryPlugin(_ref) {
  var sentryHub = _ref.sentryHub,
    sentryClient = _ref.sentryClient,
    shouldSendTelemetry = _ref.shouldSendTelemetry,
    logger = _ref.logger;
  return {
    name: "sentry-telemetry-plugin",
    buildStart: function buildStart() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return shouldSendTelemetry;
            case 2:
              if (!_context.sent) {
                _context.next = 7;
                break;
              }
              logger.info("Sending error and performance telemetry data to Sentry. To disable telemetry, set `options.telemetry` to `false`.");
              sentryHub.startTransaction({
                name: "Sentry Bundler Plugin execution"
              }).finish();
              _context.next = 7;
              return sentryClient.flush(3000);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}

function createLogger(options) {
  return {
    info: function info(message) {
      if (!options.silent) {
        var _console;
        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          params[_key - 1] = arguments[_key];
        }
        // eslint-disable-next-line no-console
        (_console = console).log.apply(_console, ["".concat(options.prefix, " Info: ").concat(message)].concat(params));
      }
    },
    warn: function warn(message) {
      if (!options.silent) {
        var _console2;
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }
        // eslint-disable-next-line no-console
        (_console2 = console).log.apply(_console2, ["".concat(options.prefix, " Warning: ").concat(message)].concat(params));
      }
    },
    error: function error(message) {
      if (!options.silent) {
        var _console3;
        for (var _len3 = arguments.length, params = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          params[_key3 - 1] = arguments[_key3];
        }
        // eslint-disable-next-line no-console
        (_console3 = console).log.apply(_console3, ["".concat(options.prefix, " Error: ").concat(message)].concat(params));
      }
    },
    debug: function debug(message) {
      if (!options.silent && options.debug) {
        var _console4;
        for (var _len4 = arguments.length, params = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          params[_key4 - 1] = arguments[_key4];
        }
        // eslint-disable-next-line no-console
        (_console4 = console).log.apply(_console4, ["".concat(options.prefix, " Debug: ").concat(message)].concat(params));
      }
    }
  };
}

var SENTRY_SAAS_HOSTNAME = "sentry.io";
function createSentryInstance(options, shouldSendTelemetry, bundler) {
  var client = new node.NodeClient({
    dsn: "https://4c2bae7d9fbc413e8f7385f55c515d51@o1.ingest.sentry.io/6690737",
    tracesSampleRate: 1,
    sampleRate: 1,
    release: "2.10.2",
    integrations: [],
    tracePropagationTargets: ["sentry.io/api"],
    stackParser: node.defaultStackParser,
    beforeSend: function beforeSend(event) {
      var _event$exception, _event$exception$valu;
      (_event$exception = event.exception) === null || _event$exception === void 0 ? void 0 : (_event$exception$valu = _event$exception.values) === null || _event$exception$valu === void 0 ? void 0 : _event$exception$valu.forEach(function (exception) {
        delete exception.stacktrace;
      });
      delete event.server_name; // Server name might contain PII
      return event;
    },
    beforeSendTransaction: function beforeSendTransaction(event) {
      delete event.server_name; // Server name might contain PII
      return event;
    },
    // We create a transport that stalls sending events until we know that we're allowed to (i.e. when Sentry CLI told
    // us that the upload URL is the Sentry SaaS URL)
    transport: function transport(nodeTransportOptions) {
      var nodeTransport = node.makeNodeTransport(nodeTransportOptions);
      return {
        flush: function flush(timeout) {
          return nodeTransport.flush(timeout);
        },
        send: function () {
          var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return shouldSendTelemetry;
                case 2:
                  if (!_context.sent) {
                    _context.next = 6;
                    break;
                  }
                  return _context.abrupt("return", nodeTransport.send(request));
                case 6:
                  return _context.abrupt("return", undefined);
                case 7:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function send(_x) {
            return _send.apply(this, arguments);
          }
          return send;
        }()
      };
    }
  });
  var hub = new node.Hub(client);
  setTelemetryDataOnHub(options, hub, bundler);
  return {
    sentryHub: hub,
    sentryClient: client
  };
}
function setTelemetryDataOnHub(options, hub, bundler) {
  var org = options.org,
    project = options.project,
    release = options.release,
    errorHandler = options.errorHandler,
    sourcemaps = options.sourcemaps;
  hub.setTag("upload-legacy-sourcemaps", !!release.uploadLegacySourcemaps);
  if (release.uploadLegacySourcemaps) {
    hub.setTag("uploadLegacySourcemapsEntries", Array.isArray(release.uploadLegacySourcemaps) ? release.uploadLegacySourcemaps.length : 1);
  }
  hub.setTag("module-metadata", !!options._experiments.moduleMetadata);
  hub.setTag("inject-build-information", !!options._experiments.injectBuildInformation);

  // Optional release pipeline steps
  hub.setTag("clean-artifacts", release.cleanArtifacts);
  if (release.setCommits) {
    hub.setTag("set-commits", release.setCommits.auto === true ? "auto" : "manual");
  } else {
    hub.setTag("set-commits", "undefined");
  }
  hub.setTag("finalize-release", release.finalize);
  hub.setTag("deploy-options", !!release.deploy);

  // Miscelaneous options
  hub.setTag("custom-error-handler", !!errorHandler);
  hub.setTag("sourcemaps-assets", !!(sourcemaps !== null && sourcemaps !== void 0 && sourcemaps.assets));
  hub.setTag("delete-after-upload", !!(sourcemaps !== null && sourcemaps !== void 0 && sourcemaps.deleteFilesAfterUpload) || !!(sourcemaps !== null && sourcemaps !== void 0 && sourcemaps.filesToDeleteAfterUpload));
  hub.setTag("node", process.version);
  hub.setTag("platform", process.platform);
  hub.setTags({
    organization: org,
    project: project,
    bundler: bundler
  });
  hub.setUser({
    id: org
  });
}
function allowedToSendTelemetry(_x2) {
  return _allowedToSendTelemetry.apply(this, arguments);
}
function _allowedToSendTelemetry() {
  _allowedToSendTelemetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
    var _cliInfo$split$, _cliInfo$split$$repla;
    var silent, org, project, authToken, url, headers, telemetry, release, cli, cliInfo, cliInfoUrl;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          silent = options.silent, org = options.org, project = options.project, authToken = options.authToken, url = options.url, headers = options.headers, telemetry = options.telemetry, release = options.release; // `options.telemetry` defaults to true
          if (!(telemetry === false)) {
            _context2.next = 3;
            break;
          }
          return _context2.abrupt("return", false);
        case 3:
          if (!(url === SENTRY_SAAS_URL)) {
            _context2.next = 5;
            break;
          }
          return _context2.abrupt("return", true);
        case 5:
          cli = new SentryCli__default["default"](null, {
            url: url,
            authToken: authToken,
            org: org,
            project: project,
            vcsRemote: release.vcsRemote,
            silent: silent,
            headers: headers
          });
          _context2.prev = 6;
          _context2.next = 9;
          return cli.execute(["info"], false);
        case 9:
          cliInfo = _context2.sent;
          _context2.next = 15;
          break;
        case 12:
          _context2.prev = 12;
          _context2.t0 = _context2["catch"](6);
          return _context2.abrupt("return", false);
        case 15:
          cliInfoUrl = (_cliInfo$split$ = cliInfo.split(/(\r\n|\n|\r)/)[0]) === null || _cliInfo$split$ === void 0 ? void 0 : (_cliInfo$split$$repla = _cliInfo$split$.replace(/^Sentry Server: /, "")) === null || _cliInfo$split$$repla === void 0 ? void 0 : _cliInfo$split$$repla.trim();
          if (!(cliInfoUrl === undefined)) {
            _context2.next = 18;
            break;
          }
          return _context2.abrupt("return", false);
        case 18:
          return _context2.abrupt("return", new URL(cliInfoUrl).hostname === SENTRY_SAAS_HOSTNAME);
        case 19:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[6, 12]]);
  }));
  return _allowedToSendTelemetry.apply(this, arguments);
}

/**
 * The sentry bundler plugin concerns itself with two things:
 * - Release injection
 * - Sourcemaps upload
 *
 * Release injection:
 * Per default the sentry bundler plugin will inject a global `SENTRY_RELEASE` into each JavaScript/TypeScript module
 * that is part of the bundle. On a technical level this is done by appending an import (`import "sentry-release-injector;"`)
 * to all entrypoint files of the user code (see `transformInclude` and `transform` hooks). This import is then resolved
 * by the sentry plugin to a virtual module that sets the global variable (see `resolveId` and `load` hooks).
 * If a user wants to inject the release into a particular set of modules they can use the `releaseInjectionTargets` option.
 *
 * Source maps upload:
 *
 * The sentry bundler plugin will also take care of uploading source maps to Sentry. This
 * is all done in the `writeBundle` hook. In this hook the sentry plugin will execute the
 * release creation pipeline:
 *
 * 1. Create a new release
 * 2. Delete already uploaded artifacts for this release (if `cleanArtifacts` is enabled)
 * 3. Upload sourcemaps based on `include` and source-map-specific options
 * 4. Associate a range of commits with the release (if `setCommits` is specified)
 * 5. Finalize the release (unless `finalize` is disabled)
 * 6. Add deploy information to the release (if `deploy` is specified)
 *
 * This release creation pipeline relies on Sentry CLI to execute the different steps.
 */
function sentryUnpluginFactory(_ref) {
  var releaseInjectionPlugin = _ref.releaseInjectionPlugin,
    moduleMetadataInjectionPlugin = _ref.moduleMetadataInjectionPlugin,
    debugIdInjectionPlugin = _ref.debugIdInjectionPlugin,
    debugIdUploadPlugin = _ref.debugIdUploadPlugin,
    bundleSizeOptimizationsPlugin = _ref.bundleSizeOptimizationsPlugin;
  return unplugin.createUnplugin(function (userOptions, unpluginMetaContext) {
    var _userOptions$silent, _userOptions$debug;
    var logger = createLogger({
      prefix: "[sentry-".concat(unpluginMetaContext.framework, "-plugin]"),
      silent: (_userOptions$silent = userOptions.silent) !== null && _userOptions$silent !== void 0 ? _userOptions$silent : false,
      debug: (_userOptions$debug = userOptions.debug) !== null && _userOptions$debug !== void 0 ? _userOptions$debug : false
    });
    var dotenvResult = dotenv__namespace.config({
      path: path__namespace.join(process.cwd(), ".env.sentry-build-plugin")
    });

    // Ignore "file not found" errors but throw all others
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore Accessing `code` on error should be safe
    if (dotenvResult.error && dotenvResult.error.code !== "ENOENT") {
      throw dotenvResult.error;
    } else if (dotenvResult.parsed) {
      logger.info('Using environment variables configured in ".env.sentry-build-plugin".');
    }
    var options = normalizeUserOptions(userOptions);
    if (unpluginMetaContext.watchMode || options.disable) {
      return [{
        name: "sentry-noop-plugin"
      }];
    }
    var shouldSendTelemetry = allowedToSendTelemetry(options);
    var _createSentryInstance = createSentryInstance(options, shouldSendTelemetry, unpluginMetaContext.framework),
      sentryHub = _createSentryInstance.sentryHub,
      sentryClient = _createSentryInstance.sentryClient;
    var sentrySession = sentryHub.startSession();
    sentryHub.captureSession();
    var sentEndSession = false; // Just to prevent infinite loops with beforeExit, which is called whenever the event loop empties out
    // We also need to manually end sesisons on errors because beforeExit is not called on crashes
    process.on("beforeExit", function () {
      if (!sentEndSession) {
        sentryHub.endSession();
        sentEndSession = true;
      }
    });

    // Set the User-Agent that Sentry CLI will use when interacting with Sentry
    process.env["SENTRY_PIPELINE"] = "".concat(unpluginMetaContext.framework, "-plugin/", "2.10.2");
    function handleRecoverableError(unknownError) {
      sentrySession.status = "abnormal";
      try {
        if (options.errorHandler) {
          try {
            if (unknownError instanceof Error) {
              options.errorHandler(unknownError);
            } else {
              options.errorHandler(new Error("An unknown error occured"));
            }
          } catch (e) {
            sentrySession.status = "crashed";
            throw e;
          }
        } else {
          sentrySession.status = "crashed";
          throw unknownError;
        }
      } finally {
        sentryHub.endSession();
      }
    }
    if (!validateOptions(options, logger)) {
      handleRecoverableError(new Error("Options were not set correctly. See output above for more details."));
    }
    if (process.cwd().match(/\\node_modules\\|\/node_modules\//)) {
      logger.warn("Running Sentry plugin from within a `node_modules` folder. Some features may not work.");
    }
    var plugins = [];
    plugins.push(telemetryPlugin({
      sentryClient: sentryClient,
      sentryHub: sentryHub,
      logger: logger,
      shouldSendTelemetry: shouldSendTelemetry
    }));
    if (options.bundleSizeOptimizations) {
      var bundleSizeOptimizations = options.bundleSizeOptimizations;
      var replacementValues = {};
      if (bundleSizeOptimizations.excludeDebugStatements) {
        replacementValues["__SENTRY_DEBUG__"] = false;
      }
      if (bundleSizeOptimizations.excludePerformanceMonitoring) {
        replacementValues["__SENTRY_TRACE__"] = false;
      }
      if (bundleSizeOptimizations.excludeReplayCanvas) {
        replacementValues["__RRWEB_EXCLUDE_CANVAS__"] = true;
      }
      if (bundleSizeOptimizations.excludeReplayIframe) {
        replacementValues["__RRWEB_EXCLUDE_IFRAME__"] = true;
      }
      if (bundleSizeOptimizations.excludeReplayShadowDom) {
        replacementValues["__RRWEB_EXCLUDE_SHADOW_DOM__"] = true;
      }
      if (bundleSizeOptimizations.excludeReplayWorker) {
        replacementValues["__SENTRY_EXCLUDE_REPLAY_WORKER__"] = true;
      }
      if (Object.keys(replacementValues).length > 0) {
        plugins.push(bundleSizeOptimizationsPlugin(replacementValues));
      }
    }
    if (!options.release.inject) {
      logger.debug("Release injection disabled via `release.inject` option. Will not inject release.");
    } else if (!options.release.name) {
      logger.warn("No release name provided. Will not inject release. Please set the `release.name` option to identify your release.");
    } else {
      var _injectionCode = generateGlobalInjectorCode({
        release: options.release.name,
        injectBuildInformation: options._experiments.injectBuildInformation || false
      });
      plugins.push(releaseInjectionPlugin(_injectionCode));
    }
    if (moduleMetadataInjectionPlugin && options._experiments.moduleMetadata) {
      var metadata;
      if (typeof options._experiments.moduleMetadata === "function") {
        var args = {
          org: options.org,
          project: options.project,
          release: options.release.name
        };
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
        metadata = options._experiments.moduleMetadata(args);
      } else {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        metadata = options._experiments.moduleMetadata;
      }
      var _injectionCode2 = generateModuleMetadataInjectorCode(metadata);
      plugins.push(moduleMetadataInjectionPlugin(_injectionCode2));
    } else if (options._experiments.moduleMetadata) {
      logger.warn("'moduleMetadata' is currently only supported by '@sentry/webpack-plugin'");
    }
    if (!options.release.name) {
      logger.warn("No release name provided. Will not create release. Please set the `release.name` option to identify your release.");
    } else if (!options.authToken) {
      logger.warn("No auth token provided. Will not create release. Please set the `authToken` option. You can find information on how to generate a Sentry auth token here: https://docs.sentry.io/api/auth/");
    } else if (!options.org && !options.authToken.startsWith("sntrys_")) {
      logger.warn("No organization slug provided. Will not create release. Please set the `org` option to your Sentry organization slug.");
    } else if (!options.project) {
      logger.warn("No project provided. Will not create release. Please set the `project` option to your Sentry project slug.");
    } else {
      plugins.push(releaseManagementPlugin({
        logger: logger,
        releaseName: options.release.name,
        shouldCreateRelease: options.release.create,
        shouldCleanArtifacts: options.release.cleanArtifacts,
        shouldFinalizeRelease: options.release.finalize,
        include: options.release.uploadLegacySourcemaps,
        setCommitsOption: options.release.setCommits,
        deployOptions: options.release.deploy,
        dist: options.release.dist,
        handleRecoverableError: handleRecoverableError,
        sentryHub: sentryHub,
        sentryClient: sentryClient,
        sentryCliOptions: {
          authToken: options.authToken,
          org: options.org,
          project: options.project,
          silent: options.silent,
          url: options.url,
          vcsRemote: options.release.vcsRemote,
          headers: options.headers
        }
      }));
    }
    plugins.push(debugIdInjectionPlugin());
    if (!options.authToken) {
      logger.warn("No auth token provided. Will not upload source maps. Please set the `authToken` option. You can find information on how to generate a Sentry auth token here: https://docs.sentry.io/api/auth/");
    } else if (!options.org && !options.authToken.startsWith("sntrys_")) {
      logger.warn("No org provided. Will not upload source maps. Please set the `org` option to your Sentry organization slug.");
    } else if (!options.project) {
      logger.warn("No project provided. Will not upload source maps. Please set the `project` option to your Sentry project slug.");
    } else {
      var _options$sourcemaps, _options$sourcemaps2, _options$sourcemaps$f, _options$sourcemaps3, _options$sourcemaps4, _options$sourcemaps5;
      plugins.push(debugIdUploadPlugin(createDebugIdUploadFunction({
        assets: (_options$sourcemaps = options.sourcemaps) === null || _options$sourcemaps === void 0 ? void 0 : _options$sourcemaps.assets,
        ignore: (_options$sourcemaps2 = options.sourcemaps) === null || _options$sourcemaps2 === void 0 ? void 0 : _options$sourcemaps2.ignore,
        filesToDeleteAfterUpload: (_options$sourcemaps$f = (_options$sourcemaps3 = options.sourcemaps) === null || _options$sourcemaps3 === void 0 ? void 0 : _options$sourcemaps3.filesToDeleteAfterUpload) !== null && _options$sourcemaps$f !== void 0 ? _options$sourcemaps$f : (_options$sourcemaps4 = options.sourcemaps) === null || _options$sourcemaps4 === void 0 ? void 0 : _options$sourcemaps4.deleteFilesAfterUpload,
        dist: options.release.dist,
        releaseName: options.release.name,
        logger: logger,
        handleRecoverableError: handleRecoverableError,
        rewriteSourcesHook: (_options$sourcemaps5 = options.sourcemaps) === null || _options$sourcemaps5 === void 0 ? void 0 : _options$sourcemaps5.rewriteSources,
        sentryHub: sentryHub,
        sentryClient: sentryClient,
        sentryCliOptions: {
          authToken: options.authToken,
          org: options.org,
          project: options.project,
          silent: options.silent,
          url: options.url,
          vcsRemote: options.release.vcsRemote,
          headers: options.headers
        }
      })));
    }
    return plugins;
  });
}
function getBuildInformation() {
  var packageJson = getPackageJson();
  var _ref2 = packageJson ? getDependencies(packageJson) : {
      deps: [],
      depsVersions: {}
    },
    deps = _ref2.deps,
    depsVersions = _ref2.depsVersions;
  return {
    deps: deps,
    depsVersions: depsVersions,
    nodeVersion: parseMajorVersion(process.version)
  };
}

/**
 * Determines whether the Sentry CLI binary is in its expected location.
 * This function is useful since `@sentry/cli` installs the binary via a post-install
 * script and post-install scripts may not always run. E.g. with `npm i --ignore-scripts`.
 */
function sentryCliBinaryExists() {
  return fs__namespace.existsSync(SentryCli__default["default"].getPath());
}
function createRollupReleaseInjectionHooks(injectionCode) {
  var virtualReleaseInjectionFileId = "\0sentry-release-injection-file";
  return {
    resolveId: function resolveId(id) {
      if (id === virtualReleaseInjectionFileId) {
        return {
          id: virtualReleaseInjectionFileId,
          external: false,
          moduleSideEffects: true
        };
      } else {
        return null;
      }
    },
    load: function load(id) {
      if (id === virtualReleaseInjectionFileId) {
        return injectionCode;
      } else {
        return null;
      }
    },
    transform: function transform(code, id) {
      if (id === virtualReleaseInjectionFileId) {
        return null;
      }

      // id may contain query and hash which will trip up our file extension logic below
      var idWithoutQueryAndHash = stripQueryAndHashFromPath(id);
      if (idWithoutQueryAndHash.match(/\\node_modules\\|\/node_modules\//)) {
        return null;
      }
      if (![".js", ".ts", ".jsx", ".tsx", ".mjs"].some(function (ending) {
        return idWithoutQueryAndHash.endsWith(ending);
      })) {
        return null;
      }
      var ms = new MagicString__default["default"](code);

      // Appending instead of prepending has less probability of mucking with user's source maps.
      // Luckily import statements get hoisted to the top anyways.
      ms.append("\n\n;import \"".concat(virtualReleaseInjectionFileId, "\";"));
      return {
        code: ms.toString(),
        map: ms.generateMap({
          hires: true
        })
      };
    }
  };
}
function createRollupBundleSizeOptimizationHooks(replacementValues) {
  return {
    transform: function transform(code) {
      return replaceBooleanFlagsInCode(code, replacementValues);
    }
  };
}

// We need to be careful not to inject the snippet before any `"use strict";`s.
// As an additional complication `"use strict";`s may come after any number of comments.
var COMMENT_USE_STRICT_REGEX =
// Note: CodeQL complains that this regex potentially has n^2 runtime. This likely won't affect realistic files.
/^(?:\s*|\/\*(?:.|\r|\n)*?\*\/|\/\/.*[\n\r])*(?:"[^"]*";|'[^']*';)?/;
function createRollupDebugIdInjectionHooks() {
  return {
    renderChunk: function renderChunk(code, chunk) {
      if ([".js", ".mjs", ".cjs"].some(function (ending) {
        return chunk.fileName.endsWith(ending);
      }) // chunks could be any file (html, md, ...)
      ) {
        var _code$match;
        var debugId = stringToUUID(code); // generate a deterministic debug ID
        var codeToInject = getDebugIdSnippet(debugId);
        var ms = new MagicString__default["default"](code, {
          filename: chunk.fileName
        });
        var match = (_code$match = code.match(COMMENT_USE_STRICT_REGEX)) === null || _code$match === void 0 ? void 0 : _code$match[0];
        if (match) {
          // Add injected code after any comments or "use strict" at the beginning of the bundle.
          ms.appendLeft(match.length, codeToInject);
        } else {
          // ms.replace() doesn't work when there is an empty string match (which happens if
          // there is neither, a comment, nor a "use strict" at the top of the chunk) so we
          // need this special case here.
          ms.prepend(codeToInject);
        }
        return {
          code: ms.toString(),
          map: ms.generateMap({
            file: chunk.fileName,
            hires: true
          })
        };
      } else {
        return null; // returning null means not modifying the chunk at all
      }
    }
  };
}

function createRollupModuleMetadataInjectionHooks(injectionCode) {
  return {
    renderChunk: function renderChunk(code, chunk) {
      if ([".js", ".mjs", ".cjs"].some(function (ending) {
        return chunk.fileName.endsWith(ending);
      }) // chunks could be any file (html, md, ...)
      ) {
        var _code$match2;
        var ms = new MagicString__default["default"](code, {
          filename: chunk.fileName
        });
        var match = (_code$match2 = code.match(COMMENT_USE_STRICT_REGEX)) === null || _code$match2 === void 0 ? void 0 : _code$match2[0];
        if (match) {
          // Add injected code after any comments or "use strict" at the beginning of the bundle.
          ms.appendLeft(match.length, injectionCode);
        } else {
          // ms.replace() doesn't work when there is an empty string match (which happens if
          // there is neither, a comment, nor a "use strict" at the top of the chunk) so we
          // need this special case here.
          ms.prepend(injectionCode);
        }
        return {
          code: ms.toString(),
          map: ms.generateMap({
            file: chunk.fileName,
            hires: true
          })
        };
      } else {
        return null; // returning null means not modifying the chunk at all
      }
    }
  };
}

function createRollupDebugIdUploadHooks(upload) {
  return {
    writeBundle: function writeBundle(outputOptions, bundle) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var outputDir, _buildArtifacts, _buildArtifacts2;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!outputOptions.dir) {
                _context.next = 9;
                break;
              }
              outputDir = outputOptions.dir;
              _context.next = 4;
              return glob.glob(["/**/*.js", "/**/*.js.map", "/**/*.mjs.map", "/**/*.cjs.map"], {
                root: outputDir,
                absolute: true,
                nodir: true
              });
            case 4:
              _buildArtifacts = _context.sent;
              _context.next = 7;
              return upload(_buildArtifacts);
            case 7:
              _context.next = 17;
              break;
            case 9:
              if (!outputOptions.file) {
                _context.next = 14;
                break;
              }
              _context.next = 12;
              return upload([outputOptions.file]);
            case 12:
              _context.next = 17;
              break;
            case 14:
              _buildArtifacts2 = Object.keys(bundle).map(function (asset) {
                return path__namespace.join(path__namespace.resolve(), asset);
              });
              _context.next = 17;
              return upload(_buildArtifacts2);
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  };
}
function getDebugIdSnippet(debugId) {
  return ";!function(){try{var e=\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{},n=(new Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]=\"".concat(debugId, "\",e._sentryDebugIdIdentifier=\"sentry-dbid-").concat(debugId, "\")}catch(e){}}();");
}

exports.createRollupBundleSizeOptimizationHooks = createRollupBundleSizeOptimizationHooks;
exports.createRollupDebugIdInjectionHooks = createRollupDebugIdInjectionHooks;
exports.createRollupDebugIdUploadHooks = createRollupDebugIdUploadHooks;
exports.createRollupModuleMetadataInjectionHooks = createRollupModuleMetadataInjectionHooks;
exports.createRollupReleaseInjectionHooks = createRollupReleaseInjectionHooks;
exports.getBuildInformation = getBuildInformation;
exports.getDebugIdSnippet = getDebugIdSnippet;
exports.replaceBooleanFlagsInCode = replaceBooleanFlagsInCode;
exports.sentryCliBinaryExists = sentryCliBinaryExists;
exports.sentryUnpluginFactory = sentryUnpluginFactory;
exports.stringToUUID = stringToUUID;
//# sourceMappingURL=index.js.map
