"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModuleFederationTypesPlugin = void 0;
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const cloudbedsRemoteManifests_1 = require("./helpers/cloudbedsRemoteManifests");
const compileTypes_1 = require("./helpers/compileTypes");
const downloadTypes_1 = require("./helpers/downloadTypes");
const logger_1 = require("./helpers/logger");
const validation_1 = require("./helpers/validation");
let isCompiledOnce = false;
let isDownloadedOnce = false;
const DEFAULT_MODULE_FEDERATION_PLUGIN_NAME = 'ModuleFederationPlugin';
class ModuleFederationTypesPlugin {
    options;
    constructor(options) {
        this.options = options;
    }
    async apply(compiler) {
        const PLUGIN_NAME = this.constructor.name;
        let logger = (0, logger_1.setLogger)(compiler.getInfrastructureLogger(PLUGIN_NAME));
        const remoteEntryUrls = this.options?.remoteEntryUrls;
        const remoteManifestUrls = (0, cloudbedsRemoteManifests_1.getRemoteManifestUrls)(this.options);
        const isCompilationDisabled = !!this.options?.disableTypeCompilation;
        const isDownloadDisabled = this.options?.disableDownladingRemoteTypes
            ?? process.env.DEPLOYMENT_ENV === constants_1.CLOUDBEDS_DEPLOYMENT_ENV_WITH_DISABLED_REMOTE_TYPES_DOWNLOAD;
        // Disable plugin when some URLs are not valid
        if (!(0, validation_1.isEveryUrlValid)(Object.values({ ...remoteEntryUrls }))) {
            logger.warn('One or more remote URLs are invalid:', remoteEntryUrls);
            logger.log('Plugin disabled');
            return;
        }
        if (!(0, validation_1.isEveryUrlValid)(Object.values({ ...remoteManifestUrls }))) {
            logger.warn('One or more remote manifest URLs are invalid:', remoteManifestUrls);
            logger.log('Plugin disabled');
            return;
        }
        // Disable plugin when both compilation and downloading of types is disabled
        if (isCompilationDisabled && isDownloadDisabled) {
            logger.log('Plugin disabled as both type compilation and download features are turned off');
            return;
        }
        // Allow for other module federation plugins such as this "NextFederationPlugin"
        const moduleFederationPluginName = this.options?.moduleFederationPluginName ?? DEFAULT_MODULE_FEDERATION_PLUGIN_NAME;
        // Get ModuleFederationPlugin config
        const federationOptions = compiler.options.plugins.find((plugin) => {
            return plugin.constructor.name === moduleFederationPluginName;
        });
        const federationPluginOptions = federationOptions?._options;
        if (!federationPluginOptions?.name) {
            logger.warn(`Plugin disabled as ${moduleFederationPluginName} is not configured properly. The 'name' option is missing.`);
            return;
        }
        // Define path for the emitted typings file
        const { exposes, remotes } = federationPluginOptions;
        const dirDist = compiler.options.devServer?.static?.directory
            || compiler.options.output?.path
            || constants_1.DEFAULT_DIR_DIST;
        const dirEmittedTypes = this.options?.dirEmittedTypes || constants_1.DEFAULT_DIR_EMITTED_TYPES;
        const dirGlobalTypes = this.options?.dirGlobalTypes || constants_1.DEFAULT_DIR_GLOBAL_TYPES;
        const dirDownloadedTypes = this.options?.dirDownloadedTypes || constants_1.DEFAULT_DIR_DOWNLOADED_TYPES;
        const tsconfig = constants_1.TS_CONFIG_FILE;
        const outFile = path_1.default.join(dirDist, dirEmittedTypes, 'index.d.ts');
        // Create types for exposed modules
        const compileTypesAfterEmit = () => {
            const { isSuccess, typeDefinitions } = (0, compileTypes_1.compileTypes)(tsconfig, exposes, outFile, dirGlobalTypes);
            if (isSuccess) {
                (0, compileTypes_1.rewritePathsWithExposedFederatedModules)(federationPluginOptions, outFile, typeDefinitions);
            }
            else {
                logger.warn('Failed to compile types for exposed modules.', (0, logger_1.getLoggerHint)(compiler));
            }
        };
        // Import types from remote modules
        const downloadRemoteTypes = async () => {
            return (0, downloadTypes_1.downloadTypes)(dirEmittedTypes, dirDownloadedTypes, remotes, remoteEntryUrls, remoteManifestUrls);
        };
        // Determine whether compilation of types should be performed continuously
        // followed by downloading of types when idle for a certain period of time
        let recompileIntervalId;
        const shouldSyncContinuously = (compiler.options.mode === 'development')
            && (this.options?.downloadTypesWhenIdleIntervalInSeconds !== -1);
        const downloadTypesWhenIdleIntervalInSeconds = this.options?.downloadTypesWhenIdleIntervalInSeconds
            || constants_1.DEFAULT_DOWNLOAD_TYPES_INTERVAL_IN_SECONDS;
        const compileTypesContinuouslyAfterEmit = () => {
            // Reset and create an Interval to redownload types every 60 seconds after compilation
            if (remotes && !isDownloadDisabled) {
                clearInterval(recompileIntervalId);
                recompileIntervalId = setInterval(() => {
                    logger.log(new Date().toLocaleString(), 'Downloading types every', downloadTypesWhenIdleIntervalInSeconds, 'seconds');
                    downloadRemoteTypes();
                }, 1000 * downloadTypesWhenIdleIntervalInSeconds);
            }
            compileTypesAfterEmit();
        };
        if (remotes && !this.options?.disableDownladingRemoteTypes) {
            compiler.hooks.beforeRun.tapPromise(PLUGIN_NAME, () => {
                logger.log('Downloading types on startup');
                return downloadRemoteTypes();
            });
            compiler.hooks.watchRun.tap(PLUGIN_NAME, () => {
                if (!isDownloadedOnce) {
                    logger.log('Downloading types on startup');
                    return downloadRemoteTypes();
                }
                return Promise.resolve();
            });
        }
        if (exposes && !isCompilationDisabled) {
            compiler.hooks.afterEmit.tap(PLUGIN_NAME, () => {
                if (shouldSyncContinuously) {
                    logger.log('Compiling types on afterEmit event');
                    compileTypesContinuouslyAfterEmit();
                }
                else if (!isCompiledOnce) {
                    isCompiledOnce = true;
                    logger.log('Compile types on startup only');
                    compileTypesAfterEmit();
                }
            });
        }
    }
}
exports.ModuleFederationTypesPlugin = ModuleFederationTypesPlugin;
//# sourceMappingURL=plugin.js.map