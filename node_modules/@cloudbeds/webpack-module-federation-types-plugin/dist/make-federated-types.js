#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const minimist_1 = __importDefault(require("minimist"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const compileTypes_1 = require("./helpers/compileTypes");
const cli_1 = require("./helpers/cli");
(0, cli_1.assertRunningFromRoot)();
const argv = (0, minimist_1.default)(process.argv.slice(2), {
    alias: {
        'global-types': 'g',
        'output-types-folder': 'o',
        'federation-config': 'c',
        'tsconfig': 't',
    },
});
const federationConfig = (0, cli_1.getFederationConfig)(argv['federation-config']);
const compileFiles = Object.values(federationConfig.exposes);
const outDir = argv['output-types-folder'] || path_1.default.join(constants_1.DEFAULT_DIR_DIST, constants_1.DEFAULT_DIR_EMITTED_TYPES);
const outFile = path_1.default.join(outDir, 'index.d.ts');
const dirGlobalTypes = argv['global-types'] || constants_1.DEFAULT_DIR_GLOBAL_TYPES;
const tsconfigPath = argv['tsconfig'] || constants_1.TS_CONFIG_FILE;
console.log(`Emitting types for ${compileFiles.length} exposed module(s)`);
const { isSuccess, typeDefinitions } = (0, compileTypes_1.compileTypes)(tsconfigPath, compileFiles, outFile, dirGlobalTypes);
if (!isSuccess) {
    process.exit(1);
}
console.log('Replacing paths with names of exposed federate modules in typings file:', outFile);
(0, compileTypes_1.rewritePathsWithExposedFederatedModules)(federationConfig, outFile, typeDefinitions);
//# sourceMappingURL=make-federated-types.js.map