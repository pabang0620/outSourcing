"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rewritePathsWithExposedFederatedModules = exports.includeTypesFromNodeModules = exports.compileTypes = exports.reportCompileDiagnostic = exports.getTSConfigCompilerOptions = void 0;
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const logger_1 = require("./logger");
const files_1 = require("./files");
function getTSConfigCompilerOptions(tsconfigFileNameOrPath) {
    const logger = (0, logger_1.getLogger)();
    const tsconfigPath = path_1.default.resolve(tsconfigFileNameOrPath);
    if (!tsconfigPath) {
        logger.error('ERROR: Could not find a valid tsconfig.json');
        process.exit(1);
    }
    return require(tsconfigPath).compilerOptions;
}
exports.getTSConfigCompilerOptions = getTSConfigCompilerOptions;
function reportCompileDiagnostic(diagnostic) {
    const logger = (0, logger_1.getLogger)();
    const { line } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
    logger.log('TS Error', diagnostic.code, ':', typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, typescript_1.default.sys.newLine));
    logger.log('         at', `${diagnostic.file.fileName}:${line + 1}`, '\n');
}
exports.reportCompileDiagnostic = reportCompileDiagnostic;
function compileTypes(tsconfigPath, exposedComponents, outFile, dirGlobalTypes) {
    const logger = (0, logger_1.getLogger)();
    const exposedFileNames = Object.values(exposedComponents);
    const { moduleResolution, ...compilerOptions } = getTSConfigCompilerOptions(tsconfigPath);
    Object.assign(compilerOptions, {
        declaration: true,
        emitDeclarationOnly: true,
        noEmit: false,
        outFile,
    });
    // Expand lib name to a file name according to https://stackoverflow.com/a/69617124/1949503
    if (compilerOptions.lib) {
        compilerOptions.lib = compilerOptions.lib.map(fileName => (fileName.includes('.d.ts') ? fileName : `lib.${fileName}.d.ts`).toLowerCase());
    }
    // Create a Program with an in-memory emit to avoid a case when wrong typings are downloaded
    let fileContent = '';
    const host = typescript_1.default.createCompilerHost(compilerOptions);
    host.writeFile = (_fileName, contents) => fileContent = contents;
    // Including global type definitions from `src/@types` directory
    if (fs_1.default.existsSync(dirGlobalTypes)) {
        exposedFileNames.push(...(0, files_1.getAllFilePaths)(`./${dirGlobalTypes}`).filter(path => path.endsWith('.d.ts')));
    }
    logger.log('Including a set of root files in compilation', exposedFileNames);
    const program = typescript_1.default.createProgram(exposedFileNames, compilerOptions, host);
    const { diagnostics, emitSkipped } = program.emit();
    diagnostics.forEach(reportCompileDiagnostic);
    return {
        isSuccess: !emitSkipped,
        typeDefinitions: fileContent,
    };
}
exports.compileTypes = compileTypes;
function includeTypesFromNodeModules(federationConfig, typings) {
    const logger = (0, logger_1.getLogger)();
    let typingsWithNpmPackages = typings;
    const exposedNpmPackages = Object.entries(federationConfig.exposes)
        .filter(([, path]) => !path.startsWith('.') || path.startsWith('./node_modules/'))
        .map(([exposedModuleKey, exposeTargetPath]) => [
        exposedModuleKey.replace(/^\.\//, ''),
        exposeTargetPath.replace('./node_modules/', ''),
    ]);
    // language=TypeScript
    const createNpmModule = (exposedModuleKey, packageName) => `
    declare module "${federationConfig.name}/${exposedModuleKey}" {
      export * from "${packageName}"
    }
  `;
    if (exposedNpmPackages.length) {
        logger.log('Including typings for npm packages:', exposedNpmPackages);
    }
    try {
        exposedNpmPackages.forEach(([exposedModuleKey, packageName]) => {
            typingsWithNpmPackages += `\n${createNpmModule(exposedModuleKey, packageName)}`;
        });
    }
    catch (err) {
        logger.warn('Typings was not included for npm package:', err?.url);
        logger.log(err);
    }
    return typingsWithNpmPackages;
}
exports.includeTypesFromNodeModules = includeTypesFromNodeModules;
function rewritePathsWithExposedFederatedModules(federationConfig, outFile, typings) {
    const regexDeclareModule = /declare module "(.*)"/g;
    const declaredModulePaths = [];
    // Collect all instances of `declare module "..."`
    let execResults = [];
    while ((execResults = regexDeclareModule.exec(typings)) !== null) {
        declaredModulePaths.push(execResults[1]);
    }
    let typingsUpdated = typings;
    // Replace and prefix paths by exposed remote names
    declaredModulePaths.forEach((importPath) => {
        // Aliases are not included in the emitted declarations hence the need to use `endsWith`
        const [exposedModuleKey, ...exposedModuleNameAliases] = Object.keys(federationConfig.exposes)
            .filter(key => (federationConfig.exposes[key].endsWith(importPath)
            || federationConfig.exposes[key].replace(/\.[^./]*$/, '').endsWith(importPath)))
            .map(key => key.replace(/^\.\//, ''));
        let federatedModulePath = exposedModuleKey
            ? `${federationConfig.name}/${exposedModuleKey}`
            : `#not-for-import/${federationConfig.name}/${importPath}`;
        federatedModulePath = federatedModulePath.replace(/\/index$/, '');
        // language=TypeScript
        const createAliasModule = (modulePath) => `
      declare module "${federationConfig.name}/${modulePath}" {
        export * from "${federatedModulePath}"
      }
    `;
        typingsUpdated = [
            typingsUpdated.replace(RegExp(`"${importPath}"`, 'g'), `"${federatedModulePath}"`),
            ...exposedModuleNameAliases.map(createAliasModule),
        ].join('\n');
    });
    typingsUpdated = includeTypesFromNodeModules(federationConfig, typingsUpdated);
    mkdirp_1.default.sync(path_1.default.dirname(outFile));
    fs_1.default.writeFileSync(outFile, typingsUpdated.replace(/\r\n/g, '\n'));
}
exports.rewritePathsWithExposedFederatedModules = rewritePathsWithExposedFederatedModules;
//# sourceMappingURL=compileTypes.js.map