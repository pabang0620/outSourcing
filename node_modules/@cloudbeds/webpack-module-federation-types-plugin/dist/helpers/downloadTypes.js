"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadTypes = exports.downloadRemoteEntryURLsFromManifests = void 0;
const download_1 = __importDefault(require("download"));
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const path_1 = __importDefault(require("path"));
const logger_1 = require("./logger");
const toCamelCase_1 = require("./toCamelCase");
const validation_1 = require("./validation");
const downloadOptions = { rejectUnauthorized: false };
async function downloadRemoteEntryManifest(url) {
    const logger = (0, logger_1.getLogger)();
    if (url.includes('{version}')) {
        const versionJsonUrl = `${url.match(/^https:\/\/[^/]+/)}/version.json`;
        const { version } = JSON.parse((await (0, download_1.default)(versionJsonUrl, downloadOptions)).toString());
        url = url.replace('{version}', version);
    }
    logger.log(`Downloading remote manifest from ${url}`);
    const json = (await (0, download_1.default)(url, downloadOptions)).toString();
    return JSON.parse(json);
}
async function downloadRemoteEntryTypes(remoteName, remoteLocation, dtsUrl, dirDownloadedTypes) {
    const logger = (0, logger_1.getLogger)();
    const remoteOriginalName = remoteLocation.split('@')[0];
    const outDir = path_1.default.join(dirDownloadedTypes, remoteName);
    const outFile = path_1.default.join(outDir, 'index.d.ts');
    let shouldWriteFile = true;
    mkdirp_1.default.sync(outDir);
    let types = (await (0, download_1.default)(dtsUrl, downloadOptions)).toString();
    // Replace original remote name (as defined in remote microapp's WMF config's `name` field)
    // with a name (an alias) that is used in `remotes` object. Usually these are same.
    if (remoteName !== remoteOriginalName) {
        types = types.replace(new RegExp(`declare module "${remoteOriginalName}(.*)"`, 'g'), (_, $1) => `declare module "${remoteName}${$1}"`);
    }
    // Prevent webpack from recompiling the bundle by not writing the file if it has not changed
    if (fs_1.default.existsSync(outFile)) {
        const typesFormer = fs_1.default.readFileSync(outFile).toString();
        shouldWriteFile = typesFormer !== types;
    }
    if (shouldWriteFile) {
        logger.info('Downloaded types from', dtsUrl);
        logger.info('Updating', outFile);
        fs_1.default.writeFileSync(outFile, types);
    }
    else {
        logger.log('Typings have not changed, skipping writing', outFile);
    }
}
/**
 * Download remote entry manifest file(s)
 * The origin of a remote entry URL is used as base URL for type definitions
 */
async function downloadRemoteEntryURLsFromManifests(remoteManifestUrls) {
    if (!remoteManifestUrls) {
        return {};
    }
    const logger = (0, logger_1.getLogger)();
    const remoteEntryURLs = {};
    logger.log('Remote manifest URLs', remoteManifestUrls);
    const { artifactsBaseUrl, ...manifestUrls } = remoteManifestUrls;
    const remoteManifests = (await Promise.all(Object.values(manifestUrls).map(url => downloadRemoteEntryManifest(url))));
    // Combine remote entry URLs from all manifests
    Object.keys(manifestUrls).forEach((remoteName, index) => {
        if (remoteName === 'registry') {
            const remotesManifest = remoteManifests[index];
            if (Array.isArray(remotesManifest)) {
                remoteManifests[index].forEach((remoteManifest) => {
                    remoteEntryURLs[remoteManifest.scope] = remoteManifest.url;
                });
            }
            else {
                Object.entries(remotesManifest).forEach(([appName, url]) => {
                    remoteEntryURLs[(0, toCamelCase_1.toCamelCase)(appName)] = (0, validation_1.isValidUrl)(url) ? url : `${artifactsBaseUrl}/${appName}/${url}`;
                });
            }
        }
        else {
            remoteEntryURLs[remoteName] = remoteManifests[index].url;
        }
    });
    logger.log('Remote entry URLs', remoteEntryURLs);
    return remoteEntryURLs;
}
exports.downloadRemoteEntryURLsFromManifests = downloadRemoteEntryURLsFromManifests;
async function downloadTypes(dirEmittedTypes, dirDownloadedTypes, remotesFromFederationConfig, remoteEntryUrls, remoteManifestUrls) {
    const logger = (0, logger_1.getLogger)();
    let remoteEntryUrlsResolved = {};
    try {
        remoteEntryUrlsResolved = {
            ...remoteEntryUrls,
            ...await downloadRemoteEntryURLsFromManifests(remoteManifestUrls),
        };
    }
    catch (err) {
        logger.warn('Failed to load remote manifest file: ', err?.url);
        logger.log(err);
        return;
    }
    const promises = [];
    Object.entries(remotesFromFederationConfig).forEach(([remoteName, remoteLocation]) => {
        try {
            const remoteEntryUrl = remoteEntryUrlsResolved[remoteName] || remoteLocation.split('@')[1];
            const remoteEntryBaseUrl = remoteEntryUrl.endsWith('.js')
                ? remoteEntryUrl.split('/').slice(0, -1).join('/')
                : remoteEntryUrl;
            const promiseDownload = downloadRemoteEntryTypes(remoteName, remoteLocation, `${remoteEntryBaseUrl}/${dirEmittedTypes}/index.d.ts`, dirDownloadedTypes);
            promises.push(promiseDownload);
        }
        catch (err) {
            logger.error(`${remoteName}: '${remoteLocation}' is not a valid remote federated module URL`);
            logger.log(err);
        }
    });
    try {
        await Promise.all(promises);
    }
    catch (err) {
        logger.warn('Failed to load remote types from:', err?.url);
        logger.log(err);
        return;
    }
    return;
}
exports.downloadTypes = downloadTypes;
//# sourceMappingURL=downloadTypes.js.map